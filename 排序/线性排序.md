# 概念
***
时间复杂度为 O(n) 的排序

# 1. 桶排序
***
## 核心思想：
***
根据排序范围，定下一系列从小到大，范围不同的桶。通过将这些桶内的元素排序，再将桶全部连起来，得到完整的排序结果。
### 复杂度分析：
- 桶内使用快排，时间复杂度为 $O(nlogn)$ 
- 假设有 n 个数，m 个桶
	- **假设均分的情况下**，那么每个桶中的元素为 $\frac{n}{m}$ 
	- 每个桶中的时间复杂度为 $\frac{n}{m}log(\frac{n}{m})$ ，所有桶合起来时间复杂度为 $O(m\cdot\frac{n}{m}log(\frac{n}{m}) )$，
	- 当 m 越多，接近 n时，时间复杂度为 O(n)
	- 当 m 越少，接近 1 时，时间复杂度退化为快排，即$O(nlogn)$ 
## 适用范围：
***
1. 数据之间很容易划分，桶之间默认大小排序
2. 每个桶内的数据量要尽量均匀

# 2. 计数排序
***
## 核心思想与操作
***
**三个数组**
1. 原数组
2. 中间数组
3. 排序数组

**操作：**
1. 中间数组的大小 = 原数组中数的范围 + 1
	遍历原数组，遍历到一个值，对应的中间数组 index 的值 + 1
2. 累加中间数组，让每一个index的值  = 小于该index的位置上的值之和
	1. 这样可以得到这个index对应的值应该处于排序数组的哪个位置
3. 再次遍历原数组，遍历到的值作为index查询在中间数组中对应的值，再将这个值作为排序数组的 index 并放入该遍历到的值
	1. 同时 中间数组的该 index 值 -1 ，保证下次遍历到时，插入正确位置
**实现代码**：
	注意点：
		1. 最后放入output中时要从后往前放，因为 index 是 从大往小 -- 的，所以从后往前才能保证稳定性，从前往后会导致原本在前面的放到后面去了
	![[IMG-20241028151531552.png]]


### 时间复杂度分析
操作 1：O(n) 
操作 2：O(n)
操作 3：O(n)
工：O(n)

## 适用范围
***
1. 数据范围不大，即数据范围与要排序的数据量相近
2. 只能处理非负数，否则要在不改变相对大小的情况下转化为非负整数才行


# 3. Radix Sort 基数排序
***
黑皮书 P110
PPT C4(iiii)P13
数据结构之美P222

## 实现思想
***
对每个数位，从小到大的排序，一共排 n 次，n 为数位数
注意点：
1. 如果数位不够的，则在前面加 0
2. 负数要提出来单独处理

### 实现代码：
每一个数位的排序都使用了counting sort ![[IMG-20241028151532109.png]]



## 时间复杂度
***
在基数排序中，每个数字的所有位数都需要处理，因此时间复杂度与数据的分布无关，最佳情况与其他情况相同。
### 最好/最坏/平均：
O(d * (n + b))
- `d` 是数字的最大位数
- `n` 是数组的长度
- `b` 是基数（在十进制数的情况下，`b = 10`）
