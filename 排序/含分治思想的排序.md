# Merge Sort
***
***
PPT：C4(i)P24
## 实现思想
***
**递归分解**：
- 使用递归，每一步都将其分为左右两部分
- 停止条件
	- left = right
**merge：**
- 从两个单独的数 得到一个排序好的两数数组
- 再从两个排序号的两数数组得到一个排序好的四数数组，依次往上

**示例代码**：
	 ![[IMG-20241028151531519.png]]

## 时间复杂度
***
### 最好：
O(n log n)
### 最坏：
O(n log n)
### 平均
O(n log n)

## 空间复杂度
***
### **空间复杂度**：
归并排序的空间复杂度是O(n)
	因为它需要使用与输入数组大小相同的额外空间来存储归并操作的结果。这使得归并排序的空间复杂度相对较高，尤其在处理大规模数据时。
### **In Place（原地算法）**：
归并排序不是一个原地算法
	因为它需要额外的空间来存储归并操作的结果。在传统的归并排序实现中，通常会使用一个与输入数组大小相同的临时数组来存储归并操作的结果，这导致了额外的空间消耗。
    
### **Stability（稳定性）**：
归并排序是一种稳定的排序算法。
	在归并操作中，如果两个相等的元素在不同的子数组中，那么它们在合并过程中会保持原来的相对顺序，从而保证了排序的稳定性。
    
### **Extra Space Complexity（额外空间复杂度）**：
额外空间复杂度是O(n)
	由于归并排序需要额外的空间来存储归并操作的结果,其中n是输入数组的大小。即使在一些优化的归并排序实现中，也需要使用额外的空间来存储部分数据，以便在归并过程中合并排序的结果。
## 适用范围
***
- 优点
	1. 特别适用于大型数据集的排序任务。
		- 无论是最好、最坏还是平均情况下，归并排序的时间复杂度都是O(n log n)，这使得它成为一种高效的排序算法
	2. 适用于链表
- 缺点
	1. 需要额外空间
    
# 快排
******
***
PPT：C4(ii) P3
黑皮书：P95
## 实现思想
通过选取合适 pivot值，将小于pivot 的放左边，将大于pivot 的放右边，最后将最后一个小于pivot的值 与 pivot 互换位置

之后再以pivot 为界，分为两小部分来递归进行该操作

终止条件：
	low < high 不再成立

- 为了避免最坏情况出现，可以每次都选数组的 mid 为 pivot

- 实例代码：
	- eg：![[IMG-20241028151532089.png]]



## 时间复杂度
***
### 最好：
O(n log n)
- 最好情况下，每次 pivot 都可以均分数组，这种情况下，n = $2^k$ ,k = log n，k为均分次数
- 每次均分的复杂度：每次都要扫描每个元素，总操作为 O(n)
- 那么总的时间复杂度就是 O(n log n)
### 最坏：
O($n^2$)
- 最坏情况是每次pivot都在边上，只能分出一个元素和剩余元素组成的数组，那么要均分 n 次
- 每次也是要遍历全部的元素，O(n)
- O(n)\*O(n)=O($n^2$) 
### 平均
O(n log n)

## 空间复杂度
***
### 空间复杂度：
快排的空间复杂度为 O(1)
- 只需要常数级的额外空间来存 pivot 等值
- 虽然使用递归，但每次调用的都是同一数组
### **In Place（原地算法）**：
快排是就地算法
- 每次调用的都是同一数组
    
### **Stability（稳定性）**：
快排不稳定
- 比如俩比 pivot 大的，因为比 pivot 小的位置出现不同，排序之后相对位置不同
    
### **Extra Space Complexity（额外空间复杂度）**：
快排的额外空间复杂度为 O(1)
- 只需要常数级的额外空间来存 pivot 等值

## 适用范围
***
快速排序适合处理大规模数据集、不需稳定性的场景、原地排序要求高、需要平均情况下较高性能以及需要自适应性的情况。



