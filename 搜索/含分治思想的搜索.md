# 线性搜索
***
做导出搜索概念，就是遍历搜索

## 时间复杂度
### Best Case：
O(1)
### Worst Case：
O(n)
### Average Case:
$O(\frac{n}{2})$ 

# Binary Search
***
***
PPT：C4(i)P10
## 适用条件
***
1. 只能用于已排序的数组
2. 快速且效率高
## 实现思想
***
1. 每一层的通用思路
	1. 已排序的数组，选 中间值 与目标值 比较。并选取下一区间，直到遇见 mid 与 target 相等 或者 再下一位 left = right = mid 与 target 相等 或者没找到
2. 递归终止条件
	1.  mid 与 target 相等
	2. 再下一位 left = right = mid 与 target 相等 或者没找到
- 实例代码：![[IMG-20241028151531533.png]]

## 时间复杂度
***
### 最好：
O(1)：就在中间
### 最坏：
O(log n)
### 平均
O(log n)

## 空间复杂度
***
### **空间复杂度**：
空间复杂度是O(1)
	即不随输入规模的增加而增加。这是因为二分查找不需要对输入数据进行排序或移动，而是通过更新指针来确定搜索范围。

### **In Place（原地算法）**：
二分查找是一种原地算法
	因为它在执行过程中只需要常数级别的额外空间来存储少量的指针和辅助变量。算法的核心是不断地更新指针来确定搜索范围，而不需要额外的数据结构来存储数据。
    
### **Stability（稳定性）**：
是一种稳定的算法
	二分查找不涉及元素的排序或移动操作,对于相等元素，二分查找能够保持它们的相对顺序不变。
    
### **Extra Space Complexity（额外空间复杂度）**：
额外空间复杂度是O(1)
	由于二分查找只需要常数级别的额外空间

# 二分思想找 max min
***
***

## 实现思想
- 代码实现
	- eg：![[IMG-20241028151532099.png]]

## 时间复杂度
***
三种情况都是 O(n) ，因为都得分到 1 / 2 然后比较

# 斐波那契搜索
***
***
