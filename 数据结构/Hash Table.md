# 思想与原理
***
要 增删改查 的值 为 Key ，key 通过 hash 函数 运算之后得到存储位置 

- 用装载因子来表示内存使用情况
	- $load factor =\frac{填入表中的元素个数}{申请的数组大小}$ 
## 散列表 与 数组的区别
散列表的基础是数组
### 1. 动态大小和高效的插入/删除操作
- **数组**：在数组中插入或删除元素通常需要移动大量元素，导致时间复杂度为O(n)。此外，数组的大小是固定的，不能动态调整。
- **哈希表**：哈希表可以动态调整大小（通过重新哈希），插入和删除操作在平均情况下时间复杂度为O(1)。

### 2. 高效的查找操作
- **数组**：查找元素在数组中的时间复杂度为O(n)，除非数组是有序的，但即使是有序数组，查找的时间复杂度也只是O(log n)（使用二分查找）。
- **哈希表**：查找操作的平均时间复杂度为O(1)，因为通过哈希函数可以直接计算出元素的位置。

### 3. 支持复杂的键类型
- **数组**：数组的索引必须是整数，并且是连续的。这意味着不能使用非整数类型的键来直接索引数组。
- **哈希表**：哈希表支持几乎任何类型的键（字符串、对象等），因为哈希函数可以将这些键转换为整数索引。

### 4. 减少冲突的灵活性
- **数组**：数组没有内置的冲突处理机制，因为它假设索引是唯一且连续的。
- **哈希表**：哈希表内置了冲突处理机制，如链地址法和开放地址法，这使得哈希表能够更好地处理键的冲突。

# 散列表的常见问题
***
## 问题：
### 1. 散列冲突：
- 多个 key 通过hash 函数得出同一个值，比如 "abc"和"cab"，因为底层都是 ascll 码在计算
#### 解决办法：
1. 开放寻址法
	1. 线性探测
		1. 假如出现散列冲突了，那么就以这个位置向后遍历，将冲突的值放在空闲位置
	2. 二次探测
		1. 在冲突位置上不是逐个检查空位，而是以 $2^n$ 个为间隔来检查空位
	3. 双重散列
		1. 给出多个hash函数，逐个使用函数，直到用其中一个函数可以找到空闲位置
2. 链表法
	1. 将同一位置的值按链表的方式存储在同一位置上】
3. 扩容
	- 当装载因子大于一定的值的时候就要扩容，一般是0.7
	- 因为hash 函数往往依赖于散列表长度，所以扩容会改变所有元素的位置。这种情况下，扩容最好使用动态扩容
		- 动态扩容即，申请新的散列表时，不要一次性将老表中的数据放入新表，而是在使用时逐次放入
			- 每次新插入数据：
				- 新数据直接放进新表
				- 同时取一个老表中的数据放入新表，并删除老表的数据

