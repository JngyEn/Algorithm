> 一种文件无损压缩技术

# 编码格式
---
## 固定长度编码

所有的字符长度都由固定数位的 bit 表示
### ASCLL
 
8bit 每个字符 

### Unicode

16bit 每个字符

## 变长度编码

### Huffman

# 构建霍夫曼树
---
- 统计每个字符的出现频率并排序
- **构建优先队列：** 创建一个优先队列（通常使用最小堆实现），队列中的每个元素是一个二叉树节点，节点包含一个符号及其对应的频率。
    
- **构建Huffman树：** 重复以下步骤直到队列中只剩下一个节点：
    
    - 从队列中取出两个频率最小的节点。
    - 创建一个新节点，该节点的频率是前两个节点频率之和。
    - 将前两个节点作为新节点的子节点，新节点没有符号。
    - 将新节点插入队列。
    
    最终得到的单个节点就是Huffman树的根节点。![[IMG-20241028151531901.png]]![[IMG-20241028151532288.png]]

# 伪代码 
---
![[IMG-20241028151533398.jpg]]
# 复杂度
***
## 时间复杂度

排序之后为线性时间

# 解码
---
>前提假设我们已经拥有用于编码的Huffman树和压缩后的二进制数据

## 步骤

1. **重建Huffman树**：
    - 在实际应用中，压缩文件通常会包含Huffman树的结构信息或频率表，用于在解码时重建Huffman树。
    - 如果已知Huffman树的结构，可以直接使用，否则需要根据频率表重建Huffman树。
2. **读取压缩数据**：
    - 读取压缩文件中的二进制数据，这些数据是按Huffman编码表编码后的结果。
3. **解码数据**：
    - 从Huffman树的根节点开始，逐位读取二进制数据，根据读到的“0”或“1”决定是向左还是向右移动。
    - 当到达一个叶子节点时，叶子节点的符号就是解码出的原始符号。
    - 之后返回根节点继续
    - 重复上述步骤直到所有二进制数据都被处理完毕。