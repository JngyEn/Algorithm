# 问题描述
---
Optimal Binary Search Tree：
假设有 𝑛 个元素 {𝑘1,𝑘2,...,𝑘𝑛} ，每个元素 𝑘𝑖​ 有一个查找概率 $p_𝑖$​
- 目标是构造一棵二叉搜索树，使得所有键的查找期望成本之和最小。
- 查找一个元素的**代价**：该元素的 **查找频率** 乘以 **查找深度**（即从根到该元素的路径长度）。
- 树的**维护代价**：每个节点的维护频率 乘以 该节点的深度。

 **虚拟（或称为哑）键**：
 除了实际的数据键外，还有一些虚拟键（用 𝑑0,𝑑1,…,𝑑𝑛表示），它们代表搜索中可能遇到的不在数据键集合中的值。这些虚拟键是二叉搜索树的外部节点（即叶子节点）。
- d0​ 代表所有小于 𝑘1​ 的值。
- 𝑑𝑛 代表所有大于 𝑘𝑛​ 的值。
- 对于 𝑖=1,2,…,𝑛−1，虚拟键 𝑑𝑖 代表所有位于 ki​ 和 𝑘𝑖+1​ 之间的值。![[IMG-20241028151531779.png]]

**计算 total cost**：
![[IMG-20241028151532272.png]]


# 五步走
---
## 1. 确定 dp数组及下标的含义

我们需要三个DP数组：

- `dp[i][j]`：从第 `i` 个关键字到第 `j` 个关键字构建最优二叉搜索树的期望搜索代价。
- `w[i][j]`：从第 `i` 个关键字到第 `j` 个关键字及其间的虚拟关键字的总概率。
- `root[i][j]`：从第 `i` 个关键字到第 `j` 个关键字构建最优二叉搜索树的根节点索引。

## 2. 确定递推公式

要构造一个最优二叉搜索树，根节点的选择非常重要。假设 `kr` 是键 `ki` 到 `kj` 之间的根节点，那么这个树的查找成本由三个部分构成：
- 根节点 `kr` 的查找成本，即 `pr`。
- 左子树的查找成本，即 `dp[i][r-1]`。
- 右子树的查找成本，即 `dp[r+1][j]`。

j = i-1 ：
表达虚拟节点，虚拟节点是从 0 - n，真实节点是 1 - n 所以 j = i-1 表达虚拟节点

当某个键成为根节点时，其左右子树中的所有节点的深度都会增加1。这就是为什么要加上 `w[i][j]`:

**所有键的概率之和**:
$w[i][j]=w[i][j−1]+p_j+q_j​$ ( j ≥ i)
= $q_{i-1}$ ( j = i-1) 
![[IMG-20241028151533322.png]]


**最小查找成本:**

$dp[i][j]=min_{i≤r≤j} \{ dp[i][r−1]+dp[r+1][j]+w[i][j] \}$ (i ≤ j) 
= $q_{i-1}$ ( j = i-1) 

## 3. DP数组如何初始化

- `dp[i][i-1] = q[i-1]` 对于每个 `i = 1` 到 `n+1`。
- `w[i][i-1] = q[i-1]` 对于每个 `i = 1` 到 `n+1`。

## 4. 确定遍历顺序

- 先遍历子树的长度 `l`，从 `1` 到 `n`。
- 对于每个长度 `l`，遍历所有可能的起始索引 `i`，并计算结束索引 `j = i + l - 1`。
- 对于每个子区间 `[i, j]`，尝试所有可能的根节点 `r`，更新 `e[i][j]` 和 `root[i][j]`。

三层 for ：
```
// 取不同子树长度
for (int l = 1; l <= n; l++) {
	// 起始节点
    for (int i = 1; i <= n-l+1; i++) {
        int j = i + l - 1;
        e[i][j] = INT_MAX;
        w[i][j] = w[i][j-1] + p[j] + q[j];
	    // 不同根节点
        for (int r = i; r <= j; r++) {
            int t = e[i][r-1] + e[r+1][j] + w[i][j];
            if (t < e[i][j]) {
                e[i][j] = t;
                root[i][j] = r;
            }
        }
    }
}
```

# 复杂度
---
## 时间复杂度

时间复杂度分析如下：
1. 外层循环 `l` 从 `1` 到 `n`，所以有 `O(n)` 次。
2. 第二层循环 `i` 取决于 `l` 的值，从 `0` 到 `n - l`，也是 `O(n)` 次。
3. 内层循环 `r` 从 `i + 1` 到 `j`，最坏情况下也是 `O(n)` 次。
总的时间复杂度为: $O(n^3)$ 
### 空间复杂度

对于空间复杂度，我们主要考虑用于存储DP表的空间：

1. `e` 表：大小为 (n+1)×(n+1)
2. `w` 表：大小为 (n+1)×(n+1)
3. `root` 表：大小为 (n+1)×(n+1)

所以，空间复杂度为： $O(n^2)$ 
# 代码
---
```
[[include]] <iostream>
[[include]] <vector>
[[include]] <limits.h>

using namespace std;

// 定义全局变量
const int MAX = 100;
double e[MAX][MAX];     // 期望搜索代价表
double w[MAX][MAX];     // 总概率表
int root[MAX][MAX];     // 根节点表

// 计算并构建最优二叉搜索树的函数
void optimalBST(const vector<double>& p, const vector<double>& q, int n) {
    // 初始化 e 和 w 表
    for (int i = 0; i <= n; ++i) {
        e[i][i] = q[i];
        w[i][i] = q[i];
    }

    // 计算 e 和 w 表的其他值
    for (int l = 1; l <= n; ++l) { // l 是子树的长度
        for (int i = 0; i <= n - l; ++i) {
            int j = i + l;
            e[i][j] = INT_MAX;
            w[i][j] = w[i][j-1] + p[j] + q[j];
            for (int r = i; r <= j; ++r) { // r 是根节点的索引
                double t = e[i][r-1] + e[r][j] + w[i][j];
                if (t < e[i][j]) {
                    e[i][j] = t;
                    root[i][j] = r;
                }
            }
        }
    }
}

// 打印最优二叉搜索树的函数
void printOBST(int i, int j, int r, const string& dir) {
    if (i < j) {
        int k = root[i][j];
        cout << "k" << k << " is the " << dir << " child of k" << r << "\n";
        printOBST(i, k-1, k, "left");
        printOBST(k, j, k, "right");
    }
}

int main() {
    // 输入概率值
    vector<double> p = {0, 0.15, 0.10, 0.05, 0.10, 0.20}; // p[0] 未使用
    vector<double> q = {0.05, 0.10, 0.05, 0.05, 0.05, 0.10};
    int n = p.size() - 1;

    // 计算最优二叉搜索树
    optimalBST(p, q, n);

    // 打印最优二叉搜索树的结构
    cout << "Root of OBST: k" << root[0][n] << "\n";
    printOBST(0, root[0][n]-1, root[0][n], "left");
    printOBST(root[0][n], n, root[0][n], "right");

    return 0;
}

```