> **求一个数据结构的一个操作序列中所执行的所有操作的平均时间 来 评估操作的代价** 
> **并不涉及概率，能保证最坏情况下每个操作的平均性能**
> **所有操作平均时间相加就得到了 - 平均时间复杂度

# 聚合分析
***
## 核心思想
将所有操作在 **最坏情况** 下消耗的总时间 ➗ 总操作数 = 平均操作时间 视为每个不同操作的时间，根据这个时间来判断算法学的性能

## 分析过程
以堆栈的 pop 和 push 为例：
- 背景设定：
	1. pop 和 push 的时间都是 O(1),
	2. 引入变量 multiPop(k)
		1. 一次弹出k个值，假设此时只有 s 个值且 k>s，那么全部弹出
		2. 时间为 O(min(s,k))
	3.  假设执行 n 次操作，每次操作类型任意
- 分析
	1. 由于 multPop 实际时 pop 的多次调用，所以 n 次之后的最坏时间为 O(n)
	2. 此时的平均操作时间为：$\frac{O(n)}{n}=O(1)$ 
- 结论
	- 这个过程的操作平均时间为 O(1)，性能线性

## 适用情况
聚合分析适合用在只需要粗略估计性能的情况下
	
# 核算法
***
## 核心思想
为每个操作预设成本，这个成本应该>=实际成本(也就是实际时间复杂度)
成本 = 实际成本 + 余额
可以用累积的余额来支付其他操作的成本
	但是总的余额不能为负（用来检验成本设计的合理性）
通过保证每一步的余额都足以支付下一步的操作来判断整个算法的成本是否可接受

## 分析过程
以堆栈的 pop 和 push 为例：
- 背景
	1. 假设为每次 push 分配 2 元，假设 pop 为 0元
		1. 考虑push 和 pop 对应
		2. 也可以是 20 200 ，这个地方的余额为操作的代价，看你是否接受
- 分析
	1. 每进行一次 push，就会产生 1 元的余额，足以支付 对应的 pop
		1. 假如每次push分配3元，进行了k次push，最后就会剩余 k 元余额，代表冗余足够

## 适用情况
精度要求高，复杂度高

# 势能法
***
## 核心思想
通过定义每一步操作的势能函数进而算出操作的摊还代价，从而评估模型性能
![[IMG-20241028151531630.png]]![[IMG-20241028151532178.png]]




